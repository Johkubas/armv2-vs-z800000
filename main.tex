\documentclass[11pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[lithuanian,english]{babel}
\usepackage{csquotes}
\usepackage{geometry}
\geometry{margin=2.5cm}
\usepackage{hyperref}
\usepackage{setspace}
\usepackage{amsmath}
\onehalfspacing

% literatūrai vėliau galėsim naudoti biblatex arba natbib;
% kol kas pakaks paprastų (Author, Year) nuorodų tekste.

\title{ARMv2 vs. Zilog Z80000:\\
Kompiuterių architektūrų palyginimas}
\author{Jokūbas Grigalius}
\date{\today}

\begin{document}

\maketitle

\section{Įvadas}
ARMv2 ir Z80000 architektūros, abi ~1986–1987 laikotarpio. 

\section{Elementinė bazė ir fizinės savybės}

\subsection{ARMv2}

ARMv2 buvo pristatytas 1987 metais ir
gaminamas naudojant CMOS technologiją su maždaug 2~µm gamybos procesu.
Procesorius turėjo apie 25 tūkst. tranzistorių, kas tuo metu buvo itin
mažas skaičius 32 bitų architektūrai. Dėl mažo tranzistorių kiekio ARM2
pasižymėjo labai mažu energijos suvartojimu ir nedideliu šilumos išsiskyrimu.

Taktinis dažnis siekė apie 8~MHz. Procesorius buvo naudojamas
\emph{Acorn Archimedes} kompiuteriuose. Fizinė procesoriaus realizacija buvo
monokristalinis mikroprocesorius viename luste. Sistema pasižymėjo nedideliais
gabaritais, maža mase ir geru energijos efektyvumu, lyginant su kitais
to meto 32 bitų sprendimais.

\subsection{Zilog Z80000}

Zilog Z80000 buvo pristatytas 1986 metais kaip 32 bitų CISC tipo
mikroprocesorius. Jis buvo gaminamas naudojant VLSI technologiją ir turėjo apie
91 tūkst. tranzistorių. Palyginus su ARMv2, Z80000 buvo stipriai sudėtingesnis
ir didesnis.

Procesorius palaikė iki 4~GiB adresuojamos atminties erdvę, turėjo vidinį
atminties valdymo bloką (MMU) ir šešių pakopų komandų vykdymo
(\emph{pipeline}). Tipiniai taktų dažniai siekė apie 10--20~MHz.

Z80000 sistemos buvo orientuotos į galingesnes darbo stotis ir pramonines
sistemas. Dėl didesnio tranzistorių skaičiaus šis procesorius naudojo daugiau
energijos, turėjo didesnį šilumos išskyrimą ir reikalavo sudėtingesnės
aušinimo bei maitinimo sistemos.

\subsection{Palyginimas}

ARMv2 pasižymėjo kompaktišku dizainu, mažu tranzistorių skaičiumi,
mažu energijos suvartojimu ir paprasta fizine realizacija, todėl puikiai
tiko kompaktiškoms sistemoms.

Tuo tarpu Zilog Z80000 buvo didesnio našumo, bet ir gerokai sudėtingesnis
procesorius su didesniu energijos poreikiu, orientuotas į galingas
skaičiavimo sistemas. Abu procesoriai naudojo VLSI technologijas, bet
jų projektavimo filosofija buvo skirtinga.

\section{Architektūrų tipas}

\subsection{ARMv2}

ARMv2 architektūra priklauso \textbf{registrinės (load/store) RISC}
architektūrų tipui \cite{WikiARM}. Tai reiškia, jog visos aritmetinės ir
loginės operacijos atliekamos tik su registrais, o atmintis naudojama tik
duomenų įkėlimui (\emph{load}) ir iškėlimui (\emph{store}).

ARMv2 architektūroje nėra akumuliatoriaus tipo operacijų, o vietoje to naudojami
bendrosios paskirties registrai. Tokia architektūra supaprastina
komandų dekodavimą ir leidžia pasiekti didelį energijos efektyvumą.

\subsection{Zilog Z80000}

Zilog Z80000 naudoja \textbf{registrinę CISC tipo architektūrą}
\cite{Z80000, WikiZ80000}. Skirtingai nuo ARMv2, ši architektūra palaiko
sudėtingas komandas, kurios gali tiesiogiai dirbti su atminties operandu be
tarpinio įkėlimo į registrą.

Z80000 taip pat naudoja bendrosios paskirties registrus, tačiau instrukcijos
yra sudėtingesnės, turi daugiau adresavimo režimų bei gali atlikti daugiau
operacijų per vieną komandą.

\subsection{Palyginimas}

ARMv2 atstovauja grynai \textbf{RISC registrinę architektūrą}, kur visos
operacijos atliekamos su registrais, o atmintis pasiekiama tik per
\emph{load/store} instrukcijas.

Z80000 atstovauja \textbf{CISC registrinę architektūrą}, kur leidžiama atlikti
operacijas tiesiogiai su atmintimi \cite{Z80000}.

Taigi nors abi architektūros naudoja registrus, jų projektavimas
gan stipriai skiriasi: ARMv2 siekia paprastumo, efektyvumo ir greičio, o Z80000 –
universalumo ir funkcionalumo.


\section{Adresų skaičius instrukcijose}

\subsection{ARMv2}

ARMv2 instrukcijų rinkinys yra tipiška trijų adresų \emph{load/store} RISC
architektūra \cite{WikiARM}. Dauguma aritmetinių ir loginių komandų turi tris
aiškiai nurodomus operandus: du šaltinius ir vieną rezultatą. Pavyzdžiui:

\begin{verbatim}
    ADD   r0, r1, r2   ; r0 = r1 + r2
\end{verbatim}

Šioje instrukcijoje registras \texttt{r1} ir \texttt{r2} yra šaltiniai, o
\texttt{r0} yra tikslinis registras. Nei atmintis, nei akumuliatorius čia nėra
naudojami kaip implicitiniai operandai, todėl ARMv2 galima laikyti
\textbf{trijų adresų mašina}.

Atminties operacijos (\texttt{LDR}, \texttt{STR}) taip pat paprastai turi
aiškiai nurodytą registrą, tikslą ir adresą, gaunamą iš bazinio registro bei
poslinkio, tačiau konceptualiai tai vis tiek atitinka trijų operandų schemą:
tikslinis registras, bazinis registras ir poslinkis.

\subsection{Zilog Z80000}

Zilog Z80000 daugumai aritmetinių ir loginių komandų naudoja dviejų adresų
formatą \cite{Z80000, WikiZ80000}. Tipinė instrukcija atrodo taip:

\begin{verbatim}
    ADD   R1, R2   ; R1 = R1 + R2
\end{verbatim}

Čia registras \texttt{R1} yra ir vienas iš šaltinių, ir rezultato saugojimo
vietą, o \texttt{R2} yra antrasis operandas. Tokia schema būdinga
\textbf{dviejų adresų mašinoms}, kur vienas operandas yra kartu ir rezultato
registras.

Daugelis komandų Z80000 leidžia vienam iš operandų būti atminties vieta
(pvz. \texttt{ADD R1, (addr)}), tačiau tai vis tiek yra dviejų
adresų forma: vienas operandas (registras) ir vienas operandas (atminties
adresas).

\subsection{Palyginimas}

ARMv2 architektūra orientuota į \textbf{trijų adresų} registrines instrukcijas,
kur aiškiai išskiriami du šaltiniai ir rezultato registras. Tai leidžia
paprasčiau optimizuoti kodą, nes nereikia papildomų komandų rezultatui
išsaugoti ar vienam iš šaltinių atstatyti.

Z80000 architektūra daugiausia naudoja \textbf{dviejų adresų} formatus, kuriuose
vienas operandas dažnai yra ir rezultato registras. Dėl to kai kurios
operacijos gali būti išreikštos trumpesniu kodu, bet kartais reikia papildomų
komandų tarpiniams rezultatams išsaugoti.

Taigi ARMv2 atitinka modernią trijų adresų RISC filosofiją, o Z80000
išlaiko tradicinę dviejų adresų CISC architektūros schemą.

\section{Registrai}

\subsection{ARMv2 registrai}

ARMv2 procesorius turi \textbf{16 bendrosios paskirties 32 bitų registrų}
(\texttt{R0–R15}) \cite{WikiARM}. Dauguma jų gali būti naudojami tiek
aritmetinėms, tiek adresavimo operacijoms. Kai kurie registrai turi ir
\textbf{specialią paskirtį}:

\begin{itemize}
  \item \texttt{R13} – (Stack Pointer, SP),
  \item \texttt{R14} – (Link Register, LR),
  \item \texttt{R15} – (Program Counter, PC).
\end{itemize}

Be bendrosios paskirties registrų, ARMv2 taip pat turi \textbf{būsenos registrą}
(\texttt{CPSR}), kuriame saugomi požymių bitai (N, Z, C, V) ir procesoriaus
režimo informacija.

Visų pagrindinių registrų duomenų plotis yra \textbf{32 bitai}, todėl ARMv2 yra
32 bitų architektūra tiek instrukcijų vykdymo, tiek registrų lygyje.

\subsection{Zilog Z80000 registrai}

Z80000 architektūra turi \textbf{16 bendrosios paskirties 32 bitų registrų}
(\texttt{R0–R15}) \cite{Z80000, WikiZ80000}. Šie registrai gali būti naudojami
aritmetinėms operacijoms, adresų skaičiavimui ir duomenų pernešimui.

Be bendrosios paskirties registrų, architektūra taip pat turi kelis
\textbf{specializuotus registrus}:

\begin{itemize}
  \item Programos skaitiklį (PC),
  \item Būsenos registrą (PSW),
  \item Pertraukimų ir režimų valdymo registrus.
\end{itemize}

Z80000 palaiko darbą tiek su 16 bitų, tiek su \textbf{32 bitų registrų poromis},
todėl daugelis operacijų gali būti vykdomos su pilna 32 bitų skaitmenų
rezoliucija.

\subsection{Palyginimas}

Abi architektūros – ARMv2 ir Z80000 – naudoja registrinį duomenų apdorojimo
modelį ir turi po \textbf{16 bendrosios paskirties 32 bitų registrų}. Tačiau
jų projektavimas skiriasi.

ARMv2 registrai yra orientuoti į greitą \emph{pipeline} vykdymą ir
efektyvų kompiliatorių darbą. Specialūs registrai (PC, LR, SP) yra integruoti į
tą pačią registrų grupę.

Z80000 leidžia lankščiai naudoti registrus tiek kaip 16 bitų, tiek kaip 32 bitų
poras, kas būdinga CISC architektūroms. Jo valdymo registrai yra labiau
atskirti nuo bendrosios paskirties registrų nei ARM architektūroje.

\section{Požymių bitai (Flags)}

\subsection{ARMv2 požymių bitai}

ARMv2 architektūroje požymių bitai yra saugomi būsenos registre
\texttt{CPSR} (Current Program Status Register) \cite{WikiARM}. Šie bitai
naudojami aritmetinių ir loginių operacijų rezultatams apibūdinti bei
šakotų komandų vykdymui valdyti.

Pagrindiniai naudojami požymių bitai yra šie:

\begin{itemize}
  \item \textbf{N (Negative)} – nustatomas, jei rezultatas yra neigiamas,
  \item \textbf{Z (Zero)} – nustatomas, jei rezultatas lygus nuliui,
  \item \textbf{C (Carry)} – nustatomas, jei operacijos metu įvyko pernešimas,
  \item \textbf{V (Overflow)} – nustatomas, jei įvyko aritmetinis perpildymas.
\end{itemize}

Šie požymiai yra naudojami sąlyginių instrukcijų vykdymui,
nes ARM architektūroje beveik visos instrukcijos gali būti vykdomos
sąlygiškai, priklausomai nuo šių flag’ų reikšmių.

\subsection{Zilog Z80000 požymių bitai}

Z80000 architektūroje požymių bitai yra saugomi
\textbf{Program Status Word (PSW)} registre \cite{Z80000}. Šis registras
apjungia tiek būsenos informaciją, tiek pertraukimų ir režimų valdymą.

Pagrindiniai Z80000 požymių bitai yra:

\begin{itemize}
  \item \textbf{Z (Zero)} – rezultatas lygus nuliui,
  \item \textbf{S (Sign)} – rezultato ženklas,
  \item \textbf{C (Carry)} – pernešimas,
  \item \textbf{V (Overflow)} – aritmetinis perpildymas.
\end{itemize}

Šie požymiai yra naudojami sąlyginiams šuoliams, ciklų valdymui ir loginėms
sprendimų konstrukcijoms.

\subsection{Palyginimas}

Abi architektūros – ARMv2 ir Z80000 – naudoja požymių bitus aritmetinių ir
loginių operacijų rezultatams įvertinti bei sąlyginiam vykdymui.

\begin{itemize}
  \item ARMv2 naudoja \texttt{CPSR} registrą ir leidžia beveik kiekvieną
  instrukciją vykdyti sąlygiškai.
  \item Z80000 naudoja \texttt{PSW} registrą, kuriame požymiai yra labiau
  tradiciškai atskirti nuo instrukcijų vykdymo logikos.
\end{itemize}

ARMv2 šioje vietoje pasižymi didesniu lankstumu ir efektyvesniu valdymu.

\section{Duomenų plotis (mašininis žodis)}

\subsection{ARMv2 duomenų plotis}

ARMv2 architektūra yra \textbf{32 bitų} sistema \cite{WikiARM}. Tai reiškia,
kad pagrindinis mašininis žodis, su kuriuo atliekamos aritmetinės, loginės ir
adresavimo operacijos, yra 32 bitų pločio. Visi bendrosios paskirties registrai
taip pat yra 32 bitų.

ARMv2 palaiko darbą su:
\begin{itemize}
  \item 8 bitų duomenimis (baitais),
  \item 16 bitų duomenimis (pusžodžiais),
  \item 32 bitų duomenimis (žodžiais).
\end{itemize}

Tai leidžia efektyviai apdoroti tiek simbolinius duomenis, tiek sveikuosius
skaičius ir atminties adresus.

\subsection{Zilog Z80000 duomenų plotis}

Z80000 architektūra taip pat yra \textbf{32 bitų} sistema \cite{Z80000}. Nors ji
palaiko suderinamumą su ankstesnėmis 16 bitų Zilog architektūromis, pagrindinis
duomenų apdorojimas vykdomas 32 bitų režimu.

Z80000 palaiko:
\begin{itemize}
  \item 8 bitų,
  \item 16 bitų,
  \item 32 bitų sveikųjų skaičių apdorojimą.
\end{itemize}

Registrai gali būti naudojami kaip pilni 32 bitų registrai arba suskaidyti į
mažesnes dalis, priklausomai nuo vykdomos instrukcijos tipo.

\subsection{Palyginimas}

Abi nagrinėjamos architektūros – ARMv2 ir Z80000 – yra \textbf{32 bitų} sistemos.
Tai reiškia, kad jų:
\begin{itemize}
  \item pagrindinis mašininis žodis yra 32 bitų,
  \item adresavimo galimybės ir aritmetinės operacijos atliekamos su 32 bitų
  skaičiais.
\end{itemize}

Skirtumas yra tas, kad ARMv2 nuo pat pradžių buvo projektuota kaip „gryna“
32 bitų RISC architektūra, o Z80000 išlaikė didesnį suderinamumą su ankstesnių
kartų 16 bitų sistemomis.

\section{Atminties išdėstymas ir adresų erdvė}

\subsection{ARMv2 atminties organizavimas}

ARMv2 architektūra turi \textbf{ištisinę (flatinę) adresų erdvę} be segmentavimo
\cite{WikiARM}. Visi atminties adresai yra interpretuojami vienodai,
nepriklausomai nuo duomenų ar programos vietos.

Efektyvus ARMv2 adresų plotis yra \textbf{32 bitai}, todėl teoriškai
maksimali adresuojama atmintis siekia:
\[
2^{32} = 4\ \text{GB}.
\]

Tipinė ARMv2 sistema turėjo nuo kelių šimtų kilobaitų iki kelių megabaitų RAM,
priklausomai nuo konkretaus įrenginio ir paskirties.

\subsection{Zilog Z80000 atminties organizavimas}

Z80000 architektūra taip pat naudoja \textbf{ištisinę 32 bitų adresų erdvę}
\cite{Z80000, WikiZ80000}. Ji nepalaiko klasikinio segmentavimo, tačiau leidžia
naudoti atminties valdymo mechanizmus per išorinius valdiklius.

Efektyvus adresų plotis yra 32 bitai, todėl maksimalus teorinis adresuojamos
atminties dydis taip pat yra:
\[
2^{32} = 4\ \text{GB}.
\]

Z80000 sistemos dažniausiai buvo komplektuojamos su nuo 1 iki 16 MB
operatyviosios atminties.

\subsection{Palyginimas}

Abi architektūros – ARMv2 ir Z80000 – turi \textbf{vieningą 32 bitų adresų erdvę}
be segmentavimo. Jų maksimalus teorinis adresuojamos atminties dydis yra vienodas
– 4 GB.

Skirtumai pasireiškia praktiniame įgyvendinime:
\begin{itemize}
  \item ARMv2 dažniau buvo naudojama įterptinėse sistemose su mažesniais atminties
  kiekiais.
  \item Z80000 buvo orientuota į galingesnes darbo stotis ar serverinius sprendimus,
  todėl tipinis RAM kiekis buvo didesnis.
\end{itemize}

\section{Virtualioji atmintis}

\subsection{ARMv2}

Pats ARMv2 procesorius \textbf{neturėjo integruotos virtualiosios atminties}
palaikymo. Tai reiškia, kad jis pats savaime negalėjo dirbti su puslapiais ar
virtualiais adresais.

Tačiau praktikoje virtualioji atmintis galėjo būti realizuojama
\textbf{naudojant išorinius atminties valdymo modulius (MMU)}. Tokiu atveju
operacinė sistema galėdavo naudoti puslapiavimą ir dirbti su virtualiais
adresais, bet tai priklausė nuo konkrečios sistemos realizacijos, o ne nuo
paties ARMv2 branduolio.

Dėl šios priežasties daugelis ARMv2 sistemų buvo paprastesnės ir dažnai dirbo be
virtualiosios atminties.

\subsection{Zilog Z80000}

Z80000 architektūra \textbf{turėjo galimybę dirbti su virtualiąja atmintimi}
per atminties valdymo mechanizmus. Ji palaikė puslapiavimu paremtą atminties
valdymą, todėl galėjo būti naudojama sudėtingesnėse sistemose su
operacinėmis sistemomis.

Tai leido:
\begin{itemize}
  \item apsaugoti atminties sritis,
  \item naudoti didesnes programas nei fizinė RAM,
  \item saugiau atskirti skirtingus procesus.
\end{itemize}

\subsection{Palyginimas}

Pagrindinis skirtumas tarp šių dviejų architektūrų yra tas, kad:

\begin{itemize}
  \item ARMv2 virtualiosios atminties tiesiogiai nepalaikė, ją buvo galima
  įgyvendinti tik per išorinius valdiklius.
  \item Z80000 jau turėjo realų virtualiosios atminties palaikymą ir galėjo būti
  naudojama sudėtingesnėse sistemose su pilnavertėmis operacinėmis sistemomis.
\end{itemize}

Todėl Z80000 šioje vietoje buvo pranašesnė, jei reikėjo dirbti su didelėmis
programomis ar keliomis užduotimis vienu metu.

\section{Komandų sistema (ISA)}

\subsection{ARMv2}

ARMv2 instrukcijų sistema yra paprasta, būdinga RISC tipo
architektūroms \cite{WikiARM, ARMv2ISA}. Dauguma instrukcijų yra vienodo ilgio
ir atlieka vieną paprastą operaciją.

Pagrindinės instrukcijų grupės:
\begin{itemize}
  \item duomenų perkėlimo (\texttt{LDR}, \texttt{STR}),
  \item aritmetinės (\texttt{ADD}, \texttt{SUB}),
  \item loginės (\texttt{AND}, \texttt{ORR}),
  \item šuolių ir programos valdymo (\texttt{B}, \texttt{BL}).
\end{itemize}

Didelis ARM privalumas – beveik kiekviena instrukcija gali būti vykdoma
sąlygiškai (pagal flag’us).

\subsection{Zilog Z80000}

Z80000 instrukcijų sistema yra sudėtingesnė ir būdinga CISC tipo
architektūroms \cite{WikiZ80000}. Instrukcijos gali būti įvairaus
ilgio ir atlikti kelis veiksmus vienu metu.

Pagrindinės instrukcijų grupės:
\begin{itemize}
  \item duomenų perkėlimo,
  \item aritmetinės,
  \item loginės,
  \item šuolių,
  \item bitų operacijų,
  \item darbo su atmintimi.
\end{itemize}

Instrukcijos leidžia tiesiogiai dirbti su atmintimi be atskiro įkėlimo
į registrą.

\subsection{Palyginimas}

ARMv2 instrukcijos yra trumpesnės, vienodo formato ir paprastos, todėl
procesorius jas vykdo greitai ir efektyviai.

Z80000 instrukcijos yra ilgesnės ir sudėtingesnės, tačiau leidžia vienoje
komandoje atlikti daugiau veiksmų.

Paprasčiau sakant:
\begin{itemize}
  \item ARMv2 – paprastumas ir greitis,
  \item Z80000 – lankstumas ir daugiau galimybių vienoje instrukcijoje.
\end{itemize}

\section{Adresavimo būdai}

\subsection{ARMv2 adresavimo būdai}

ARMv2 palaiko ribotą, bet efektyvią adresavimo sistemą, būdingą RISC architektūroms. Pagrindiniai adresavimo režimai:

\begin{itemize}
    \item Tiesioginis adresavimas su poslinkiu iš registro.
    \item Registrų netiesioginis adresavimas.
    \item Pre-index ir post-index adresavimas su automatiniu registro atnaujinimu.
    \item PC-reliatyvus adresavimas.
    \item Tiesioginis (immediate) adresavimas.
\end{itemize}

ARMv2 architektūroje dauguma operacijų atliekamos naudojant registrus, o atmintis pasiekiama tik per \textit{load} ir \textit{store} instrukcijas.

\subsection{Z80000 adresavimo būdai}

Z80000 palaiko daug platesnį adresavimo režimų rinkinį, būdingą CISC tipo architektūroms:

\begin{itemize}
    \item Tiesioginis adresavimas.
    \item Registrų netiesioginis adresavimas.
    \item Registrų netiesioginis su poslinkiu.
    \item Indeksuotas adresavimas.
    \item Kombinuotas bazės, indekso ir poslinkio adresavimas.
    \item Segmentuotas adresavimas.
    \item PC-reliatyvus adresavimas.
    \item Tiesioginis (immediate) adresavimas.
\end{itemize}

Z80000 architektūra leidžia atlikti sudėtingas atminties operacijas vienoje instrukcijoje.

\subsection{Palyginimas}

ARMv2 naudoja paprastesnius ir greitesnius adresavimo režimus, orientuotus į registrų naudojimą. Z80000 palaiko daugiau skirtingų adresavimo būdų, suteikiančių didesnį lankstumą, bet didesnį sudėtingumą. Z80000 palaiko segmentuotą atmintį, kurios ARMv2 neturi.

\section{I/O galimybės}

\subsection{ARMv2 I/O galimybės}

ARMv2 architektūra nenaudoja specialaus I/O adresų intervalo. Vietoje to, I/O įrenginiai pasiekiami per \textbf{memory-mapped I/O}, t.~y. įrenginiai yra atvaizduojami į tą pačią adresų erdvę kaip ir RAM. Tai supaprastina procesoriaus dizainą ir leidžia naudoti tas pačias \texttt{LDR}/\texttt{STR} instrukcijas duomenims perduoti.

ARMv2 I/O savybės:
\begin{itemize}
    \item Memory-mapped I/O yra vienintelis palaikomas mechanizmas.
    \item I/O įrenginių registrai pasiekiami naudojant standartines atminties instrukcijas.
    \item Paprastesnis valdymas, bet reikalaujama kruopščios įrenginių adresų planavimo schemos.
\end{itemize}


\subsection{Z80000 I/O galimybės}

Z80000 architektūra, kaip ir dauguma Zilog šeimos procesorių, palaiko du atskirus metodus:

\begin{itemize}
    \item \textbf{Memory-mapped I/O}
    \item \textbf{Atskirtą I/O adresų erdvę} (port-based I/O)
\end{itemize}

Z80000 turi specialias instrukcijas (pvz., \texttt{IN}, \texttt{OUT}), kurios leidžia tiesiogiai skaityti arba rašyti duomenis į I/O prievadus. Taip pat Z80000 gali naudoti atminties adresus I/O įrenginiams tuo pačiu būdu kaip ARMv2.

Z80000 I/O savybės:
\begin{itemize}
    \item Tiek port-based, tiek memory-mapped I/O palaikymas.
    \item Galima atskirti I/O adresus nuo RAM, taip padidinant saugumą ir aiškumą.
    \item Specialios I/O instrukcijos leidžia greitesnį įrenginių aptarnavimą.
\end{itemize}


\subsection{Palyginimas}

\begin{itemize}
    \item ARMv2 turi paprastesnę, vieningą I/O sistemą — \textbf{tik memory-mapped I/O}.
    \item Z80000 suteikia daugiau lankstumo, palaikydamas \textbf{dvi I/O sistemas}, įskaitant specializuotas I/O instrukcijas.
    \item ARMv2 požiūris lemia paprastesnį procesoriaus dizainą, o Z80000 — didesnes galimybes ir sudėtingesnius I/O valdymo scenarijus.
\end{itemize}

\section{Pertraukimai}

\subsection{ARMv2 pertraukimai}

ARMv2 architektūroje pertraukimai naudojami išoriniams įvykiams apdoroti, pavyzdžiui, įvesties/I/O įrenginių signalams ar laikmačio įvykiams. ARMv2 palaiko kelias pagrindines pertraukimų rūšis.

Pagrindiniai ARMv2 pertraukimai:
\begin{itemize}
    \item \textbf{IRQ (Interrupt Request)} – paprastas išorinis pertraukimas.
    \item \textbf{FIQ (Fast Interrupt Request)} – greitas pertraukimas, skirtas svarbiems įvykiams.
\end{itemize}

ARMv2 pertraukimų savybės:
\begin{itemize}
    \item Pertraukimų metu procesorius automatiškai išsaugo būseną.
    \item FIQ turi didesnį prioritetą nei IRQ.
    \item Yra atskiri registrai, skirti pertraukimų apdorojimui.
    \item Galima programiškai įjungti arba išjungti pertraukimus.
\end{itemize}


\subsection{Z80000 pertraukimai}

Z80000 architektūra taip pat palaiko išorinius pertraukimus, kurie naudojami greitam reakcijos laikui į įrenginių siunčiamus signalus.

Z80000 pertraukimų savybės:
\begin{itemize}
    \item Palaikomi keli pertraukimų lygiai (prioritetai).
    \item Pertraukimai gali būti maskuojami (išjungiami).
    \item Pertraukimai perduoda valdymą į iš anksto nustatytus pertraukimo apdorojimo adresus.
    \item Galimas vektorizuotų pertraukimų palaikymas.
\end{itemize}


\subsection{Palyginimas}

\begin{itemize}
    \item ARMv2 turi aiškiai atskirtus \textbf{IRQ} ir \textbf{FIQ}, leidžiančius itin greitai reaguoti į svarbius įvykius.
    \item Z80000 siūlo \textbf{kelių lygių pertraukimų sistemą}, leidžiančią lanksčiau valdyti prioritetus.
    \item Abi architektūros leidžia programiškai valdyti pertraukimų įjungimą ir išjungimą.
\end{itemize}

\section{Duomenų tipai}

\subsection{ARMv2 duomenų tipai}

ARMv2 architektūra aparatinės įrangos lygiu palaiko pagrindinius sveikųjų
skaičių duomenų tipus. Pagrindinis palaikomas skaitinis formatas yra
\textbf{dvejeto papildinys (two's complement)}, kuris naudojamas visiems
pasirašytiems sveikiesiems skaičiams.

ARMv2 palaikomi duomenų tipai:
\begin{itemize}
    \item 8 bitų sveikieji skaičiai (baitai),
    \item 16 bitų sveikieji skaičiai,
    \item 32 bitų sveikieji skaičiai,
    \item loginiai duomenys (bitų lygio operacijos).
\end{itemize}

Slankiojo kablelio aritmetika ARMv2 procesoriuje \textbf{nebuvo realizuota
aparatūriškai} – ji galėjo būti atliekama tik programiškai arba naudojant
atskirus išorinius skaičiavimo modulius.

\subsection{Zilog Z80000 duomenų tipai}

Z80000 architektūra taip pat palaiko \textbf{dvejeto papildinio} sveikųjų
skaičių formatą. Ji leidžia dirbti tiek su mažesniais, tiek su pilnais
32 bitų duomenimis.

Z80000 palaikomi duomenų tipai:
\begin{itemize}
    \item 8 bitų sveikieji skaičiai,
    \item 16 bitų sveikieji skaičiai,
    \item 32 bitų sveikieji skaičiai,
    \item loginiai ir bitų lygio duomenys.
\end{itemize}

Kaip ir ARMv2 atveju, \textbf{slankiojo kablelio aritmetika nebuvo integruota}
į patį Z80000 procesorių ir buvo realizuojama per papildomus koprocesorius
arba programiniu būdu.

\subsection{Palyginimas}

\begin{itemize}
    \item Abi architektūros naudoja \textbf{dvejeto papildinio} formatą
    pasirašytiems sveikiesiems skaičiams.
    \item Tiek ARMv2, tiek Z80000 palaiko 8, 16 ir 32 bitų sveikųjų skaičių
    duomenis.
    \item Nei ARMv2, nei Z80000 neturi integruoto slankiojo kablelio
    skaičiavimo aparato.
\end{itemize}

Abi architektūros buvo daugiau orientuotos į bendro pobūdžio skaitinius
skaičiavimus ir valdymo užduotis, o ne į sudėtingą mokslinę slankiojo kablelio
aritmetiką.

\section{Greitaveika}

\subsection{ARMv2 greitaveika}

ARMv2 procesoriai veikė santykinai nedideliais, bet tuo metu pakankamai
efektyviais dažniais. Tipiniai ARMv2 procesorių taktinių generatorių dažniai
buvo apie \textbf{8--12 MHz}.

Dauguma ARMv2 instrukcijų buvo įvykdomos per \textbf{1 ciklą}, todėl reali
greitaveika dažnai buvo artima taktiniam dažniui. Dėl paprastos RISC
architektūros ARMv2 pasižymėjo gera energijos vartojimo ir našumo pusiausvyra.

Kur ARMv2 buvo greitesnis:
\begin{itemize}
    \item trumpesnis instrukcijų vykdymo laikas,
    \item mažesnis energijos suvartojimas,
    \item paprastesnis „pipeline“ mechanizmas.
\end{itemize}

\subsection{Zilog Z80000 greitaveika}

Z80000 procesoriai buvo projektuojami kaip galingesni 32 bitų CISC procesoriai.
Jų tipiniai taktinių generatorių dažniai siekė \textbf{10--20 MHz}.

Dėl sudėtingesnių instrukcijų dauguma operacijų buvo vykdomos per
\textbf{kelis taktinius ciklus}. Tai reiškia, kad nors dažnis galėjo būti
šiek tiek didesnis nei ARMv2, realus vienos instrukcijos vykdymo laikas
dažnai buvo ilgesnis.

Z80000 greitaveikos ypatybės:
\begin{itemize}
    \item sudėtingesnės instrukcijos,
    \item daugiau ciklų vienai komandai,
    \item didesnis lankstumas, bet mažesnis efektyvumas.
\end{itemize}

\subsection{Palyginimas}

\begin{itemize}
    \item ARMv2 dažniausiai atlikdavo daugiau instrukcijų per tą patį laiką,
    nes dauguma jų vykdomos per 1 ciklą.
    \item Z80000 galėjo turėti šiek tiek didesnį taktinį dažnį, bet dažnai
    prarasdavo pranašumą dėl kelių ciklų instrukcijų.
    \item ARMv2 turėjo geresnį energijos ir našumo santykį.
\end{itemize}

Galima teigti, kad praktikoje ARMv2 dažniau pasirodydavo efektyvesnis,
ypač įterptinėse sistemose, tuo tarpu Z80000 buvo orientuotas į universalesnes
skaičiavimo užduotis.





\bibliographystyle{plain}
\bibliography{bib/refs}
\end{document}
