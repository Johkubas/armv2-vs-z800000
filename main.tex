\documentclass[11pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[lithuanian,english]{babel}
\usepackage{csquotes}
\usepackage{geometry}
\geometry{margin=2.5cm}
\usepackage{hyperref}
\usepackage{setspace}
\onehalfspacing

% literatūrai vėliau galėsim naudoti biblatex arba natbib;
% kol kas pakaks paprastų (Author, Year) nuorodų tekste.

\title{ARMv2 vs. Zilog Z80000:\\
Kompiuterių architektūrų palyginimas}
\author{Jokūbas Grigalius}
\date{\today}

\begin{document}

\maketitle

\section{Įvadas}
ARMv2 ir Z80000 architektūros, abi ~1986–1987 laikotarpio. 

\section{Elementinė bazė ir fizinės savybės}

\subsection{ARMv2}

ARMv2 buvo pristatytas 1987 metais ir
gaminamas naudojant CMOS technologiją su maždaug 2~µm gamybos procesu.
Šis procesorius turėjo apie 25 tūkst. tranzistorių, kas tuo metu buvo itin
mažas skaičius 32 bitų architektūrai. Dėl mažo tranzistorių kiekio ARM2
pasižymėjo labai mažu energijos suvartojimu ir nedideliu šilumos išsiskyrimu.

Tipinis taktinis dažnis siekė apie 8~MHz. Procesorius buvo naudojamas
\emph{Acorn Archimedes} kompiuteriuose. Fizinė procesoriaus realizacija buvo
monokristalinis mikroprocesorius viename luste. Sistema pasižymėjo nedideliais
gabaritais, maža mase ir itin geru energijos efektyvumu, lyginant su kitais
to meto 32 bitų sprendimais.

\subsection{Zilog Z80000}

Zilog Z80000 buvo pristatytas 1986 metais kaip 32 bitų CISC tipo
mikroprocesorius. Jis buvo gaminamas naudojant VLSI technologiją ir turėjo apie
91 tūkst. tranzistorių. Palyginus su ARMv2, Z80000 buvo gerokai sudėtingesnis
ir didesnis.

Procesorius palaikė iki 4~GiB adresuojamos atminties erdvę, turėjo vidinį
atminties valdymo bloką (MMU) ir šešių pakopų komandų vykdymo
(\emph{pipeline}). Tipiniai taktų dažniai siekė apie 10--20~MHz.

Z80000 sistemos buvo orientuotos į galingesnes darbo stotis ir pramonines
sistemas. Dėl didesnio tranzistorių skaičiaus šis procesorius naudojo daugiau
energijos, turėjo didesnį šilumos išskyrimą ir reikalavo sudėtingesnės
aušinimo bei maitinimo sistemos.

\subsection{Palyginimas}

ARMv2 pasižymėjo itin kompaktišku dizainu, mažu tranzistorių skaičiumi,
mažu energijos suvartojimu ir paprasta fizine realizacija, todėl puikiai
tiko kompaktiškoms sistemoms.

Tuo tarpu Zilog Z80000 buvo didesnio našumo, bet ir gerokai sudėtingesnis
procesorius su didesniu energijos poreikiu, orientuotas į galingas
skaičiavimo sistemas. Abu procesoriai naudojo VLSI technologijas, tačiau
jų projektavimo filosofija buvo iš esmės skirtinga.

\section{Architektūrų tipas}

\subsection{ARMv2}

ARMv2 architektūra priklauso \textbf{registrinės rinkinės (load/store) RISC}
architektūrų tipui \cite{WikiARM}. Tai reiškia, jog visos aritmetinės ir
loginės operacijos atliekamos tik su registrais, o atmintis naudojama tik
duomenų įkėlimui (\emph{load}) ir iškėlimui (\emph{store}).

ARMv2 architektūroje nėra akumuliatoriaus tipo operacijų – vietoje to naudojami
bendrosios paskirties registrai. Tokia architektūra supaprastina
komandų dekodavimą ir leidžia pasiekti didelį energijos efektyvumą.

\subsection{Zilog Z80000}

Zilog Z80000 naudoja \textbf{registrinę CISC tipo architektūrą}
\cite{Z80000, WikiZ80000}. Skirtingai nuo ARMv2, ši architektūra palaiko
sudėtingas komandas, kurios gali tiesiogiai dirbti su atminties operandu be
tarpinio įkėlimo į registrą.

Z80000 taip pat naudoja bendrosios paskirties registrus, tačiau instrukcijos
yra sudėtingesnės, turi daugiau adresavimo režimų bei gali atlikti daugiau
operacijų per vieną komandą.

\subsection{Palyginimas}

ARMv2 atstovauja grynai \textbf{RISC registrinę architektūrą}, kur visos
operacijos atliekamos su registrais, o atmintis pasiekiama tik per
\emph{load/store} instrukcijas.

Z80000 atstovauja \textbf{CISC registrinę architektūrą}, kur leidžiama atlikti
operacijas tiesiogiai su atmintimi \cite{Z80000}.

Taigi nors abi architektūros naudoja registrus, jų projektavimo filosofija
esmingai skiriasi: ARMv2 siekia paprastumo, efektyvumo ir greičio, o Z80000 –
universalumo ir funkcionalumo.


\section{Adresų skaičius instrukcijose}

\subsection{ARMv2}

ARMv2 instrukcijų rinkinys yra tipiška trijų adresų \emph{load/store} RISC
architektūra \cite{WikiARM}. Dauguma aritmetinių ir loginių komandų turi tris
aiškiai nurodomus operandus: du šaltinius ir vieną rezultatą. Pavyzdžiui:

\begin{verbatim}
    ADD   r0, r1, r2   ; r0 = r1 + r2
\end{verbatim}

Šioje instrukcijoje registras \texttt{r1} ir \texttt{r2} yra šaltiniai, o
\texttt{r0} yra tikslinis registras. Nei atmintis, nei akumuliatorius čia nėra
naudojami kaip implicitiniai operandai, todėl ARMv2 galima laikyti
\textbf{trijų adresų mašina} (bent jau pagrindinėms R–R operacijoms).

Atminties operacijos (\texttt{LDR}, \texttt{STR}) taip pat paprastai turi
aiškiai nurodytą registrą - tikslą ir adresą, gaunamą iš bazinio registro bei
poslinkio, tačiau konceptualiai tai vis tiek atitinka trijų operandų schemą:
tikslinis registras, bazinis registras ir poslinkis.

\subsection{Zilog Z80000}

Zilog Z80000 daugumai aritmetinių ir loginių komandų naudoja dviejų adresų
formatą \cite{Z80000, WikiZ80000}. Tipinė instrukcija atrodo taip:

\begin{verbatim}
    ADD   R1, R2   ; R1 = R1 + R2
\end{verbatim}

Čia registras \texttt{R1} yra ir vienas iš šaltinių, ir rezultato saugojimo
vietą, o \texttt{R2} – antrasis operandas. Tokia schema būdinga
\textbf{dviejų adresų mašinoms}, kur vienas operandas yra kartu ir rezultato
registras.

Daugelis komandų Z80000 leidžia vienam iš operandų būti atminties vieta
(pvz. \texttt{ADD R1, (addr)}), tačiau konceptualiai tai vis tiek yra dviejų
adresų forma: vienas operandas (registras) ir vienas operandas (atminties
adresas).

\subsection{Palyginimas}

ARMv2 architektūra orientuota į \textbf{trijų adresų} registrines instrukcijas,
kur aiškiai išskiriami du šaltiniai ir rezultato registras. Tai leidžia
paprasčiau optimizuoti kodą, nes nereikia papildomų komandų rezultatui
išsaugoti ar vienam iš šaltinių atstatyti.

Z80000 architektūra daugiausia naudoja \textbf{dviejų adresų} formatus, kuriuose
vienas operandas dažnai yra ir rezultato registras. Dėl to kai kurios
operacijos gali būti išreikštos trumpesniu kodu, bet kartais reikia papildomų
komandų tarpiniams rezultatams išsaugoti.

Taigi ARMv2 atitinka modernią trijų adresų RISC filosofiją, tuo tarpu Z80000
išlaiko tradicinę dviejų adresų CISC architektūros schemą.

\section{Registrai}

\subsection{ARMv2 registrai}

ARMv2 procesorius turi \textbf{16 bendrosios paskirties 32 bitų registrų}
(\texttt{R0–R15}) \cite{WikiARM}. Dauguma jų gali būti naudojami tiek
aritmetinėms, tiek adresavimo operacijoms. Kai kurie registrai turi ir
\textbf{specialią paskirtį}:

\begin{itemize}
  \item \texttt{R13} – steko registras (Stack Pointer, SP),
  \item \texttt{R14} – grįžimo adresų registras (Link Register, LR),
  \item \texttt{R15} – programos skaitiklis (Program Counter, PC).
\end{itemize}

Be bendrosios paskirties registrų, ARMv2 taip pat turi \textbf{būsenos registrą}
(\texttt{CPSR}), kuriame saugomi požymių bitai (N, Z, C, V) ir procesoriaus
režimo informacija.

Visų pagrindinių registrų duomenų plotis yra \textbf{32 bitai}, todėl ARMv2 yra
32 bitų architektūra tiek instrukcijų vykdymo, tiek registrų lygyje.

\subsection{Zilog Z80000 registrai}

Z80000 architektūra turi \textbf{16 bendrosios paskirties 32 bitų registrų}
(\texttt{R0–R15}) \cite{Z80000, WikiZ80000}. Šie registrai gali būti naudojami
aritmetinėms operacijoms, adresų skaičiavimui ir duomenų pernešimui.

Be bendrosios paskirties registrų, architektūra taip pat turi kelis
\textbf{specializuotus registrus}:

\begin{itemize}
  \item Programos skaitiklį (PC),
  \item Būsenos registrą (PSW),
  \item Pertraukimų ir režimų valdymo registrus.
\end{itemize}

Z80000 palaiko darbą tiek su 16 bitų, tiek su \textbf{32 bitų registrų poromis},
todėl daugelis operacijų gali būti vykdomos su pilna 32 bitų skaitmenų
rezoliucija.

\subsection{Palyginimas}

Abi architektūros – ARMv2 ir Z80000 – naudoja registrinį duomenų apdorojimo
modelį ir turi po \textbf{16 bendrosios paskirties 32 bitų registrų}. Tačiau
jų projektavimas skiriasi.

ARMv2 registrai yra orientuoti į greitą \emph{pipeline} vykdymą ir
efektyvų kompiliatorių darbą. Specialūs registrai (PC, LR, SP) yra integruoti į
tą pačią registrų grupę.

Z80000 leidžia lankščiai naudoti registrus tiek kaip 16 bitų, tiek kaip 32 bitų
poras, kas būdinga CISC architektūroms. Jo valdymo registrai yra labiau
atskirti nuo bendrosios paskirties registrų nei ARM architektūroje.

\section{Požymių bitai (Flags)}

\subsection{ARMv2 požymių bitai}

ARMv2 architektūroje požymių bitai yra saugomi būsenos registre
\texttt{CPSR} (Current Program Status Register) \cite{WikiARM}. Šie bitai
naudojami aritmetinių ir loginių operacijų rezultatams apibūdinti bei
šakotų komandų vykdymui valdyti.

Pagrindiniai naudojami požymių bitai yra šie:

\begin{itemize}
  \item \textbf{N (Negative)} – nustatomas, jei rezultatas yra neigiamas,
  \item \textbf{Z (Zero)} – nustatomas, jei rezultatas lygus nuliui,
  \item \textbf{C (Carry)} – nustatomas, jei operacijos metu įvyko pernešimas,
  \item \textbf{V (Overflow)} – nustatomas, jei įvyko aritmetinis perpildymas.
\end{itemize}

Šie požymiai yra naudojami sąlyginių instrukcijų vykdymui,
nes ARM architektūroje beveik visos instrukcijos gali būti vykdomos
sąlygiškai, priklausomai nuo šių flag’ų reikšmių.

\subsection{Zilog Z80000 požymių bitai}

Z80000 architektūroje požymių bitai yra saugomi
\textbf{Program Status Word (PSW)} registre \cite{Z80000}. Šis registras
apjungia tiek būsenos informaciją, tiek pertraukimų ir režimų valdymą.

Pagrindiniai Z80000 požymių bitai yra:

\begin{itemize}
  \item \textbf{Z (Zero)} – rezultatas lygus nuliui,
  \item \textbf{S (Sign)} – rezultato ženklas,
  \item \textbf{C (Carry)} – pernešimas,
  \item \textbf{V (Overflow)} – aritmetinis perpildymas.
\end{itemize}

Šie požymiai yra naudojami sąlyginiams šuoliams, ciklų valdymui ir loginėms
sprendimų konstrukcijoms.

\subsection{Palyginimas}

Abi architektūros – ARMv2 ir Z80000 – naudoja požymių bitus aritmetinių ir
loginių operacijų rezultatams įvertinti bei sąlyginiam vykdymui.

\begin{itemize}
  \item ARMv2 naudoja \texttt{CPSR} registrą ir leidžia beveik kiekvieną
  instrukciją vykdyti sąlygiškai.
  \item Z80000 naudoja \texttt{PSW} registrą, kuriame požymiai yra labiau
  tradiciškai atskirti nuo instrukcijų vykdymo logikos.
\end{itemize}

ARMv2 šioje vietoje pasižymi didesniu lankstumu ir efektyvesniu valdymu.


\bibliographystyle{plain}
\bibliography{bib/refs}
\end{document}
