\documentclass[11pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[lithuanian,english]{babel}
\usepackage{csquotes}
\usepackage{geometry}
\geometry{margin=2.5cm}
\usepackage{hyperref}
\usepackage{setspace}
\onehalfspacing

% literatūrai vėliau galėsim naudoti biblatex arba natbib;
% kol kas pakaks paprastų (Author, Year) nuorodų tekste.

\title{ARMv2 vs. Zilog Z80000:\\
Kompiuterių architektūrų palyginimas}
\author{Jokūbas Grigalius}
\date{\today}

\begin{document}

\maketitle

\section{Įvadas}
ARMv2 ir Z80000 architektūros, abi ~1986–1987 laikotarpio. 

\section{Elementinė bazė ir fizinės savybės}

\subsection{ARMv2}

ARMv2 buvo pristatytas 1987 metais ir
gaminamas naudojant CMOS technologiją su maždaug 2~µm gamybos procesu.
Procesorius turėjo apie 25 tūkst. tranzistorių, kas tuo metu buvo itin
mažas skaičius 32 bitų architektūrai. Dėl mažo tranzistorių kiekio ARM2
pasižymėjo labai mažu energijos suvartojimu ir nedideliu šilumos išsiskyrimu.

Taktinis dažnis siekė apie 8~MHz. Procesorius buvo naudojamas
\emph{Acorn Archimedes} kompiuteriuose. Fizinė procesoriaus realizacija buvo
monokristalinis mikroprocesorius viename luste. Sistema pasižymėjo nedideliais
gabaritais, maža mase ir geru energijos efektyvumu, lyginant su kitais
to meto 32 bitų sprendimais.

\subsection{Zilog Z80000}

Zilog Z80000 buvo pristatytas 1986 metais kaip 32 bitų CISC tipo
mikroprocesorius. Jis buvo gaminamas naudojant VLSI technologiją ir turėjo apie
91 tūkst. tranzistorių. Palyginus su ARMv2, Z80000 buvo stipriai sudėtingesnis
ir didesnis.

Procesorius palaikė iki 4~GiB adresuojamos atminties erdvę, turėjo vidinį
atminties valdymo bloką (MMU) ir šešių pakopų komandų vykdymo
(\emph{pipeline}). Tipiniai taktų dažniai siekė apie 10--20~MHz.

Z80000 sistemos buvo orientuotos į galingesnes darbo stotis ir pramonines
sistemas. Dėl didesnio tranzistorių skaičiaus šis procesorius naudojo daugiau
energijos, turėjo didesnį šilumos išskyrimą ir reikalavo sudėtingesnės
aušinimo bei maitinimo sistemos.

\subsection{Palyginimas}

ARMv2 pasižymėjo kompaktišku dizainu, mažu tranzistorių skaičiumi,
mažu energijos suvartojimu ir paprasta fizine realizacija, todėl puikiai
tiko kompaktiškoms sistemoms.

Tuo tarpu Zilog Z80000 buvo didesnio našumo, bet ir gerokai sudėtingesnis
procesorius su didesniu energijos poreikiu, orientuotas į galingas
skaičiavimo sistemas. Abu procesoriai naudojo VLSI technologijas, bet
jų projektavimo filosofija buvo skirtinga.

\section{Architektūrų tipas}

\subsection{ARMv2}

ARMv2 architektūra priklauso \textbf{registrinės (load/store) RISC}
architektūrų tipui \cite{WikiARM}. Tai reiškia, jog visos aritmetinės ir
loginės operacijos atliekamos tik su registrais, o atmintis naudojama tik
duomenų įkėlimui (\emph{load}) ir iškėlimui (\emph{store}).

ARMv2 architektūroje nėra akumuliatoriaus tipo operacijų, o vietoje to naudojami
bendrosios paskirties registrai. Tokia architektūra supaprastina
komandų dekodavimą ir leidžia pasiekti didelį energijos efektyvumą.

\subsection{Zilog Z80000}

Zilog Z80000 naudoja \textbf{registrinę CISC tipo architektūrą}
\cite{Z80000, WikiZ80000}. Skirtingai nuo ARMv2, ši architektūra palaiko
sudėtingas komandas, kurios gali tiesiogiai dirbti su atminties operandu be
tarpinio įkėlimo į registrą.

Z80000 taip pat naudoja bendrosios paskirties registrus, tačiau instrukcijos
yra sudėtingesnės, turi daugiau adresavimo režimų bei gali atlikti daugiau
operacijų per vieną komandą.

\subsection{Palyginimas}

ARMv2 atstovauja grynai \textbf{RISC registrinę architektūrą}, kur visos
operacijos atliekamos su registrais, o atmintis pasiekiama tik per
\emph{load/store} instrukcijas.

Z80000 atstovauja \textbf{CISC registrinę architektūrą}, kur leidžiama atlikti
operacijas tiesiogiai su atmintimi \cite{Z80000}.

Taigi nors abi architektūros naudoja registrus, jų projektavimas
gan stipriai skiriasi: ARMv2 siekia paprastumo, efektyvumo ir greičio, o Z80000 –
universalumo ir funkcionalumo.


\section{Adresų skaičius instrukcijose}

\subsection{ARMv2}

ARMv2 instrukcijų rinkinys yra tipiška trijų adresų \emph{load/store} RISC
architektūra \cite{WikiARM}. Dauguma aritmetinių ir loginių komandų turi tris
aiškiai nurodomus operandus: du šaltinius ir vieną rezultatą. Pavyzdžiui:

\begin{verbatim}
    ADD   r0, r1, r2   ; r0 = r1 + r2
\end{verbatim}

Šioje instrukcijoje registras \texttt{r1} ir \texttt{r2} yra šaltiniai, o
\texttt{r0} yra tikslinis registras. Nei atmintis, nei akumuliatorius čia nėra
naudojami kaip implicitiniai operandai, todėl ARMv2 galima laikyti
\textbf{trijų adresų mašina}.

Atminties operacijos (\texttt{LDR}, \texttt{STR}) taip pat paprastai turi
aiškiai nurodytą registrą, tikslą ir adresą, gaunamą iš bazinio registro bei
poslinkio, tačiau konceptualiai tai vis tiek atitinka trijų operandų schemą:
tikslinis registras, bazinis registras ir poslinkis.

\subsection{Zilog Z80000}

Zilog Z80000 daugumai aritmetinių ir loginių komandų naudoja dviejų adresų
formatą \cite{Z80000, WikiZ80000}. Tipinė instrukcija atrodo taip:

\begin{verbatim}
    ADD   R1, R2   ; R1 = R1 + R2
\end{verbatim}

Čia registras \texttt{R1} yra ir vienas iš šaltinių, ir rezultato saugojimo
vietą, o \texttt{R2} yra antrasis operandas. Tokia schema būdinga
\textbf{dviejų adresų mašinoms}, kur vienas operandas yra kartu ir rezultato
registras.

Daugelis komandų Z80000 leidžia vienam iš operandų būti atminties vieta
(pvz. \texttt{ADD R1, (addr)}), tačiau tai vis tiek yra dviejų
adresų forma: vienas operandas (registras) ir vienas operandas (atminties
adresas).

\subsection{Palyginimas}

ARMv2 architektūra orientuota į \textbf{trijų adresų} registrines instrukcijas,
kur aiškiai išskiriami du šaltiniai ir rezultato registras. Tai leidžia
paprasčiau optimizuoti kodą, nes nereikia papildomų komandų rezultatui
išsaugoti ar vienam iš šaltinių atstatyti.

Z80000 architektūra daugiausia naudoja \textbf{dviejų adresų} formatus, kuriuose
vienas operandas dažnai yra ir rezultato registras. Dėl to kai kurios
operacijos gali būti išreikštos trumpesniu kodu, bet kartais reikia papildomų
komandų tarpiniams rezultatams išsaugoti.

Taigi ARMv2 atitinka modernią trijų adresų RISC filosofiją, o Z80000
išlaiko tradicinę dviejų adresų CISC architektūros schemą.

\section{Registrai}

\subsection{ARMv2 registrai}

ARMv2 procesorius turi \textbf{16 bendrosios paskirties 32 bitų registrų}
(\texttt{R0–R15}) \cite{WikiARM}. Dauguma jų gali būti naudojami tiek
aritmetinėms, tiek adresavimo operacijoms. Kai kurie registrai turi ir
\textbf{specialią paskirtį}:

\begin{itemize}
  \item \texttt{R13} – (Stack Pointer, SP),
  \item \texttt{R14} – (Link Register, LR),
  \item \texttt{R15} – (Program Counter, PC).
\end{itemize}

Be bendrosios paskirties registrų, ARMv2 taip pat turi \textbf{būsenos registrą}
(\texttt{CPSR}), kuriame saugomi požymių bitai (N, Z, C, V) ir procesoriaus
režimo informacija.

Visų pagrindinių registrų duomenų plotis yra \textbf{32 bitai}, todėl ARMv2 yra
32 bitų architektūra tiek instrukcijų vykdymo, tiek registrų lygyje.

\subsection{Zilog Z80000 registrai}

Z80000 architektūra turi \textbf{16 bendrosios paskirties 32 bitų registrų}
(\texttt{R0–R15}) \cite{Z80000, WikiZ80000}. Šie registrai gali būti naudojami
aritmetinėms operacijoms, adresų skaičiavimui ir duomenų pernešimui.

Be bendrosios paskirties registrų, architektūra taip pat turi kelis
\textbf{specializuotus registrus}:

\begin{itemize}
  \item Programos skaitiklį (PC),
  \item Būsenos registrą (PSW),
  \item Pertraukimų ir režimų valdymo registrus.
\end{itemize}

Z80000 palaiko darbą tiek su 16 bitų, tiek su \textbf{32 bitų registrų poromis},
todėl daugelis operacijų gali būti vykdomos su pilna 32 bitų skaitmenų
rezoliucija.

\subsection{Palyginimas}

Abi architektūros – ARMv2 ir Z80000 – naudoja registrinį duomenų apdorojimo
modelį ir turi po \textbf{16 bendrosios paskirties 32 bitų registrų}. Tačiau
jų projektavimas skiriasi.

ARMv2 registrai yra orientuoti į greitą \emph{pipeline} vykdymą ir
efektyvų kompiliatorių darbą. Specialūs registrai (PC, LR, SP) yra integruoti į
tą pačią registrų grupę.

Z80000 leidžia lankščiai naudoti registrus tiek kaip 16 bitų, tiek kaip 32 bitų
poras, kas būdinga CISC architektūroms. Jo valdymo registrai yra labiau
atskirti nuo bendrosios paskirties registrų nei ARM architektūroje.

\section{Požymių bitai (Flags)}

\subsection{ARMv2 požymių bitai}

ARMv2 architektūroje požymių bitai yra saugomi būsenos registre
\texttt{CPSR} (Current Program Status Register) \cite{WikiARM}. Šie bitai
naudojami aritmetinių ir loginių operacijų rezultatams apibūdinti bei
šakotų komandų vykdymui valdyti.

Pagrindiniai naudojami požymių bitai yra šie:

\begin{itemize}
  \item \textbf{N (Negative)} – nustatomas, jei rezultatas yra neigiamas,
  \item \textbf{Z (Zero)} – nustatomas, jei rezultatas lygus nuliui,
  \item \textbf{C (Carry)} – nustatomas, jei operacijos metu įvyko pernešimas,
  \item \textbf{V (Overflow)} – nustatomas, jei įvyko aritmetinis perpildymas.
\end{itemize}

Šie požymiai yra naudojami sąlyginių instrukcijų vykdymui,
nes ARM architektūroje beveik visos instrukcijos gali būti vykdomos
sąlygiškai, priklausomai nuo šių flag’ų reikšmių.

\subsection{Zilog Z80000 požymių bitai}

Z80000 architektūroje požymių bitai yra saugomi
\textbf{Program Status Word (PSW)} registre \cite{Z80000}. Šis registras
apjungia tiek būsenos informaciją, tiek pertraukimų ir režimų valdymą.

Pagrindiniai Z80000 požymių bitai yra:

\begin{itemize}
  \item \textbf{Z (Zero)} – rezultatas lygus nuliui,
  \item \textbf{S (Sign)} – rezultato ženklas,
  \item \textbf{C (Carry)} – pernešimas,
  \item \textbf{V (Overflow)} – aritmetinis perpildymas.
\end{itemize}

Šie požymiai yra naudojami sąlyginiams šuoliams, ciklų valdymui ir loginėms
sprendimų konstrukcijoms.

\subsection{Palyginimas}

Abi architektūros – ARMv2 ir Z80000 – naudoja požymių bitus aritmetinių ir
loginių operacijų rezultatams įvertinti bei sąlyginiam vykdymui.

\begin{itemize}
  \item ARMv2 naudoja \texttt{CPSR} registrą ir leidžia beveik kiekvieną
  instrukciją vykdyti sąlygiškai.
  \item Z80000 naudoja \texttt{PSW} registrą, kuriame požymiai yra labiau
  tradiciškai atskirti nuo instrukcijų vykdymo logikos.
\end{itemize}

ARMv2 šioje vietoje pasižymi didesniu lankstumu ir efektyvesniu valdymu.

\section{Duomenų plotis (mašininis žodis)}

\subsection{ARMv2 duomenų plotis}

ARMv2 architektūra yra \textbf{32 bitų} sistema \cite{WikiARM}. Tai reiškia,
kad pagrindinis mašininis žodis, su kuriuo atliekamos aritmetinės, loginės ir
adresavimo operacijos, yra 32 bitų pločio. Visi bendrosios paskirties registrai
taip pat yra 32 bitų.

ARMv2 palaiko darbą su:
\begin{itemize}
  \item 8 bitų duomenimis (baitais),
  \item 16 bitų duomenimis (pusžodžiais),
  \item 32 bitų duomenimis (žodžiais).
\end{itemize}

Tai leidžia efektyviai apdoroti tiek simbolinius duomenis, tiek sveikuosius
skaičius ir atminties adresus.

\subsection{Zilog Z80000 duomenų plotis}

Z80000 architektūra taip pat yra \textbf{32 bitų} sistema \cite{Z80000}. Nors ji
palaiko suderinamumą su ankstesnėmis 16 bitų Zilog architektūromis, pagrindinis
duomenų apdorojimas vykdomas 32 bitų režimu.

Z80000 palaiko:
\begin{itemize}
  \item 8 bitų,
  \item 16 bitų,
  \item 32 bitų sveikųjų skaičių apdorojimą.
\end{itemize}

Registrai gali būti naudojami kaip pilni 32 bitų registrai arba suskaidyti į
mažesnes dalis, priklausomai nuo vykdomos instrukcijos tipo.

\subsection{Palyginimas}

Abi nagrinėjamos architektūros – ARMv2 ir Z80000 – yra \textbf{32 bitų} sistemos.
Tai reiškia, kad jų:
\begin{itemize}
  \item pagrindinis mašininis žodis yra 32 bitų,
  \item adresavimo galimybės ir aritmetinės operacijos atliekamos su 32 bitų
  skaičiais.
\end{itemize}

Skirtumas yra tas, kad ARMv2 nuo pat pradžių buvo projektuota kaip „gryna“
32 bitų RISC architektūra, o Z80000 išlaikė didesnį suderinamumą su ankstesnių
kartų 16 bitų sistemomis.

\section{Atminties išdėstymas ir adresų erdvė}

\subsection{ARMv2 atminties organizavimas}

ARMv2 architektūra turi \textbf{ištisinę (flatinę) adresų erdvę} be segmentavimo
\cite{WikiARM}. Visi atminties adresai yra interpretuojami vienodai,
nepriklausomai nuo duomenų ar programos vietos.

Efektyvus ARMv2 adresų plotis yra \textbf{32 bitai}, todėl teoriškai
maksimali adresuojama atmintis siekia:
\[
2^{32} = 4\ \text{GB}.
\]

Tipinė ARMv2 sistema turėjo nuo kelių šimtų kilobaitų iki kelių megabaitų RAM,
priklausomai nuo konkretaus įrenginio ir paskirties.

\subsection{Zilog Z80000 atminties organizavimas}

Z80000 architektūra taip pat naudoja \textbf{ištisinę 32 bitų adresų erdvę}
\cite{Z80000, WikiZ80000}. Ji nepalaiko klasikinio segmentavimo, tačiau leidžia
naudoti atminties valdymo mechanizmus per išorinius valdiklius.

Efektyvus adresų plotis yra 32 bitai, todėl maksimalus teorinis adresuojamos
atminties dydis taip pat yra:
\[
2^{32} = 4\ \text{GB}.
\]

Z80000 sistemos dažniausiai buvo komplektuojamos su nuo 1 iki 16 MB
operatyviosios atminties.

\subsection{Palyginimas}

Abi architektūros – ARMv2 ir Z80000 – turi \textbf{vieningą 32 bitų adresų erdvę}
be segmentavimo. Jų maksimalus teorinis adresuojamos atminties dydis yra vienodas
– 4 GB.

Skirtumai pasireiškia praktiniame įgyvendinime:
\begin{itemize}
  \item ARMv2 dažniau buvo naudojama įterptinėse sistemose su mažesniais atminties
  kiekiais.
  \item Z80000 buvo orientuota į galingesnes darbo stotis ar serverinius sprendimus,
  todėl tipinis RAM kiekis buvo didesnis.
\end{itemize}



\bibliographystyle{plain}
\bibliography{bib/refs}
\end{document}
